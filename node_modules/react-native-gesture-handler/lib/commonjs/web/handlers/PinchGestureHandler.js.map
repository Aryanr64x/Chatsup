{"version":3,"sources":["PinchGestureHandler.ts"],"names":["PinchGestureHandler","GestureHandler","onScaleBegin","detector","startingSpan","getCurrentSpan","onScale","event","prevScaleFactor","scale","getScaleFactor","tracker","getTrackedPointersCount","delta","getTimeDelta","velocity","Math","abs","spanSlop","currentState","State","BEGAN","activate","onScaleEnd","_detector","_event","ScaleGestureDetector","scaleDetectorListener","init","ref","propsRef","setShouldCancelWhenOutside","DEFAULT_TOUCH_SLOP","updateGestureConfig","enabled","props","transformNativeEvent","focalX","scaleGestureDetector","getFocusX","focalY","getFocusY","onPointerDown","addToTracker","tryBegin","onTouchEvent","onPointerUp","removeFromTracker","pointerId","ACTIVE","end","eventType","EventTypes","UP","fail","onPointerMove","track","onPointerOutOfBounds","onPointerCancel","reset","UNDETERMINED","resetProgress","begin","force","onReset"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { DEFAULT_TOUCH_SLOP } from '../constants';\nimport { AdaptedPointerEvent, EventTypes } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nimport ScaleGestureDetector, {\n  ScaleGestureListener,\n} from '../detectors/ScaleGestureDetector';\n\nexport default class PinchGestureHandler extends GestureHandler {\n  private scale = 1;\n  private velocity = 0;\n\n  private startingSpan = 0;\n  private spanSlop = 0;\n\n  private scaleDetectorListener: ScaleGestureListener = {\n    onScaleBegin: (detector: ScaleGestureDetector): boolean => {\n      this.startingSpan = detector.getCurrentSpan();\n      return true;\n    },\n    onScale: (\n      detector: ScaleGestureDetector,\n      event: AdaptedPointerEvent\n    ): boolean => {\n      const prevScaleFactor: number = this.scale;\n      this.scale *= detector.getScaleFactor(\n        this.tracker.getTrackedPointersCount()\n      );\n\n      const delta = detector.getTimeDelta();\n      if (delta > 0) {\n        this.velocity = (this.scale - prevScaleFactor) / delta;\n      }\n\n      if (\n        Math.abs(this.startingSpan - detector.getCurrentSpan()) >=\n          this.spanSlop &&\n        this.currentState === State.BEGAN\n      ) {\n        this.activate(event);\n      }\n      return true;\n    },\n    onScaleEnd: (\n      _detector: ScaleGestureDetector,\n      _event: AdaptedPointerEvent\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ): void => {},\n  };\n\n  private scaleGestureDetector: ScaleGestureDetector = new ScaleGestureDetector(\n    this.scaleDetectorListener\n  );\n\n  public init(ref: number, propsRef: React.RefObject<unknown>) {\n    super.init(ref, propsRef);\n\n    this.setShouldCancelWhenOutside(false);\n    this.spanSlop = DEFAULT_TOUCH_SLOP;\n  }\n\n  public updateGestureConfig({ enabled = true, ...props }): void {\n    super.updateGestureConfig({ enabled: enabled, ...props });\n\n    this.enabled = enabled;\n  }\n\n  protected transformNativeEvent(_event: AdaptedPointerEvent) {\n    return {\n      focalX: this.scaleGestureDetector.getFocusX(),\n      focalY: this.scaleGestureDetector.getFocusY(),\n      velocity: this.velocity,\n      scale: this.scale,\n    };\n  }\n\n  protected onPointerDown(event: AdaptedPointerEvent): void {\n    super.onPointerDown(event);\n\n    this.tracker.addToTracker(event);\n\n    if (this.tracker.getTrackedPointersCount() < 2) {\n      return;\n    }\n\n    if (this.tracker.getTrackedPointersCount() > 1) {\n      this.tryBegin(event);\n      this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    }\n  }\n  protected onPointerUp(event: AdaptedPointerEvent): void {\n    if (this.tracker.getTrackedPointersCount() > 1) {\n      this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n      this.tracker.removeFromTracker(event.pointerId);\n    } else {\n      this.tracker.removeFromTracker(event.pointerId);\n      if (this.currentState !== State.ACTIVE) {\n        return;\n      }\n      this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    }\n    if (\n      this.currentState === State.ACTIVE &&\n      this.tracker.getTrackedPointersCount() < 2\n    ) {\n      this.end(event);\n    } else if (\n      event.eventType === EventTypes.UP &&\n      this.currentState !== State.BEGAN\n    ) {\n      this.fail(event);\n    }\n  }\n  protected onPointerMove(event: AdaptedPointerEvent): void {\n    if (this.tracker.getTrackedPointersCount() < 2) {\n      return;\n    }\n    this.tracker.track(event);\n\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerMove(event);\n  }\n  protected onPointerOutOfBounds(_event: AdaptedPointerEvent): void {\n    //\n  }\n\n  protected onPointerCancel(_event: AdaptedPointerEvent): void {\n    this.reset();\n  }\n\n  private tryBegin(event: AdaptedPointerEvent): void {\n    if (this.currentState !== State.UNDETERMINED) {\n      return;\n    }\n\n    this.resetProgress();\n\n    this.begin(event);\n  }\n\n  protected activate(event: AdaptedPointerEvent, force?: boolean): void {\n    if (this.currentState !== State.ACTIVE) {\n      this.resetProgress();\n    }\n\n    super.activate(event, force);\n  }\n\n  protected onReset(): void {\n    this.resetProgress();\n  }\n\n  protected resetProgress(): void {\n    if (this.currentState === State.ACTIVE) {\n      return;\n    }\n\n    this.velocity = 0;\n    this.scale = 1;\n  }\n}\n"]}