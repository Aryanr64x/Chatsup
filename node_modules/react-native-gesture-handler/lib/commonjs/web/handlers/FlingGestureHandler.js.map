{"version":3,"sources":["FlingGestureHandler.ts"],"names":["DEFAULT_MAX_DURATION_MS","DEFAULT_MIN_ACCEPTABLE_DELTA","DEFAULT_DIRECTION","Direction","RIGHT","DEFAULT_NUMBER_OF_TOUCHES_REQUIRED","FlingGestureHandler","GestureHandler","init","ref","propsRef","updateGestureConfig","enabled","props","config","direction","numberOfPointers","numberOfPointersRequired","transformNativeEvent","event","x","offsetX","y","offsetY","absoluteX","absoluteY","startFling","startX","startY","begin","maxNumberOfPointersSimultaneously","delayTimeout","setTimeout","fail","maxDurationMs","tryEndFling","minAcceptableDelta","LEFT","UP","DOWN","clearTimeout","activate","endFling","onPointerDown","tracker","addToTracker","currentState","State","UNDETERMINED","BEGAN","getTrackedPointersCount","onPointerMove","track","onPointerUp","removeFromTracker","pointerId","force","end","resetConfig"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { Direction } from '../constants';\nimport { AdaptedPointerEvent } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\n\nconst DEFAULT_MAX_DURATION_MS = 800;\nconst DEFAULT_MIN_ACCEPTABLE_DELTA = 160;\nconst DEFAULT_DIRECTION = Direction.RIGHT;\nconst DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;\n\nexport default class FlingGestureHandler extends GestureHandler {\n  private numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n  private direction = DEFAULT_DIRECTION;\n\n  private maxDurationMs = DEFAULT_MAX_DURATION_MS;\n  private minAcceptableDelta = DEFAULT_MIN_ACCEPTABLE_DELTA;\n  private delayTimeout!: number;\n\n  private startX = 0;\n  private startY = 0;\n\n  private maxNumberOfPointersSimultaneously = 0;\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n  }\n\n  public updateGestureConfig({ enabled = true, ...props }): void {\n    super.updateGestureConfig({ enabled: enabled, ...props });\n\n    this.enabled = enabled;\n\n    if (this.config.direction) {\n      this.direction = this.config.direction;\n    }\n\n    if (this.config.numberOfPointers) {\n      this.numberOfPointersRequired = this.config.numberOfPointers;\n    }\n  }\n\n  protected transformNativeEvent(event: AdaptedPointerEvent) {\n    return {\n      x: event.offsetX,\n      y: event.offsetY,\n      absoluteX: event.x,\n      absoluteY: event.y,\n    };\n  }\n\n  private startFling(event: AdaptedPointerEvent): void {\n    this.startX = event.x;\n    this.startY = event.y;\n\n    this.begin(event);\n\n    this.maxNumberOfPointersSimultaneously = 1;\n\n    this.delayTimeout = setTimeout(() => this.fail(event), this.maxDurationMs);\n  }\n\n  private tryEndFling(event: AdaptedPointerEvent): boolean {\n    if (\n      this.maxNumberOfPointersSimultaneously ===\n        this.numberOfPointersRequired &&\n      ((this.direction & Direction.RIGHT &&\n        event.x - this.startX > this.minAcceptableDelta) ||\n        (this.direction & Direction.LEFT &&\n          this.startX - event.x > this.minAcceptableDelta) ||\n        (this.direction & Direction.UP &&\n          this.startY - event.y > this.minAcceptableDelta) ||\n        (this.direction & Direction.DOWN &&\n          event.y - this.startY > this.minAcceptableDelta))\n    ) {\n      clearTimeout(this.delayTimeout);\n      this.activate(event);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private endFling(event: AdaptedPointerEvent) {\n    if (!this.tryEndFling(event)) {\n      this.fail(event);\n    }\n  }\n\n  protected onPointerDown(event: AdaptedPointerEvent): void {\n    super.onPointerDown(event);\n\n    this.tracker.addToTracker(event);\n\n    if (this.currentState === State.UNDETERMINED) {\n      this.startFling(event);\n    }\n\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling(event);\n\n    if (\n      this.tracker.getTrackedPointersCount() >\n      this.maxNumberOfPointersSimultaneously\n    ) {\n      this.maxNumberOfPointersSimultaneously = this.tracker.getTrackedPointersCount();\n    }\n  }\n\n  protected onPointerMove(event: AdaptedPointerEvent): void {\n    this.tracker.track(event);\n\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling(event);\n\n    super.onPointerMove(event);\n  }\n\n  protected onPointerUp(event: AdaptedPointerEvent): void {\n    this.tracker.removeFromTracker(event.pointerId);\n\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n\n    this.endFling(event);\n  }\n\n  protected activate(event: AdaptedPointerEvent, force?: boolean): void {\n    super.activate(event, force);\n    this.end(event);\n  }\n\n  protected resetConfig(): void {\n    super.resetConfig();\n    this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n    this.direction = DEFAULT_DIRECTION;\n  }\n}\n"]}