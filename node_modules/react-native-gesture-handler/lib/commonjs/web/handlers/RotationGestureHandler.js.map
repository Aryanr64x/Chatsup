{"version":3,"sources":["RotationGestureHandler.ts"],"names":["ROTATION_RECOGNITION_THRESHOLD","Math","PI","RotationGestureHandler","GestureHandler","onRotationBegin","_detector","onRotation","detector","event","previousRotation","rotation","getRotation","delta","getTimeDelta","velocity","abs","currentState","State","BEGAN","activate","onRotationEnd","end","RotationGestureDetector","rotationGestureListener","init","ref","propsRef","setShouldCancelWhenOutside","updateGestureConfig","enabled","props","transformNativeEvent","_event","anchorX","getAnchorX","anchorY","getAnchorY","rotationGestureDetector","cachedAnchorX","cachedAnchorY","onPointerDown","tracker","addToTracker","getTrackedPointersCount","tryBegin","onTouchEvent","onPointerMove","track","onPointerUp","resetTracker","removeFromTracker","pointerId","ACTIVE","eventType","EventTypes","UP","fail","onPointerCancel","reset","UNDETERMINED","resetProgress","begin","_force","onReset"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { AdaptedPointerEvent, EventTypes } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nimport RotationGestureDetector, {\n  RotationGestureListener,\n} from '../detectors/RotationGestureDetector';\n\nconst ROTATION_RECOGNITION_THRESHOLD = Math.PI / 36;\n\nexport default class RotationGestureHandler extends GestureHandler {\n  private rotation = 0;\n  private velocity = 0;\n\n  private cachedAnchorX = 0;\n  private cachedAnchorY = 0;\n\n  private rotationGestureListener: RotationGestureListener = {\n    onRotationBegin: (_detector: RotationGestureDetector): boolean => true,\n    onRotation: (\n      detector: RotationGestureDetector,\n      event: AdaptedPointerEvent\n    ): boolean => {\n      const previousRotation: number = this.rotation;\n      this.rotation += detector.getRotation();\n\n      const delta = detector.getTimeDelta();\n\n      if (delta > 0) {\n        this.velocity = (this.rotation - previousRotation) / delta;\n      }\n\n      if (\n        Math.abs(this.rotation) >= ROTATION_RECOGNITION_THRESHOLD &&\n        this.currentState === State.BEGAN\n      ) {\n        this.activate(event);\n      }\n\n      return true;\n    },\n    onRotationEnd: (\n      _detector: RotationGestureDetector,\n      event: AdaptedPointerEvent\n    ): void => {\n      this.end(event);\n    },\n  };\n\n  private rotationGestureDetector: RotationGestureDetector = new RotationGestureDetector(\n    this.rotationGestureListener\n  );\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n\n    this.setShouldCancelWhenOutside(false);\n  }\n\n  public updateGestureConfig({ enabled = true, ...props }): void {\n    super.updateGestureConfig({ enabled: enabled, ...props });\n\n    this.enabled = enabled;\n  }\n\n  protected transformNativeEvent(_event: AdaptedPointerEvent) {\n    return {\n      rotation: this.rotation ? this.rotation : 0,\n      anchorX: this.getAnchorX(),\n      anchorY: this.getAnchorY(),\n      velocity: this.velocity ? this.velocity : 0,\n    };\n  }\n\n  public getAnchorX(): number {\n    const anchorX = this.rotationGestureDetector.getAnchorX();\n\n    return anchorX ? anchorX : this.cachedAnchorX;\n  }\n\n  public getAnchorY(): number {\n    const anchorY = this.rotationGestureDetector.getAnchorY();\n\n    return anchorY ? anchorY : this.cachedAnchorY;\n  }\n\n  protected onPointerDown(event: AdaptedPointerEvent): void {\n    super.onPointerDown(event);\n\n    this.tracker.addToTracker(event);\n\n    if (this.tracker.getTrackedPointersCount() <= 1) {\n      return;\n    }\n\n    this.tryBegin(event);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n  }\n\n  protected onPointerMove(event: AdaptedPointerEvent): void {\n    if (\n      this.tracker.getTrackedPointersCount() < 2 ||\n      !this.rotationGestureDetector\n    ) {\n      return;\n    }\n\n    if (this.getAnchorX()) {\n      this.cachedAnchorX = this.getAnchorX();\n    }\n    if (this.getAnchorY()) {\n      this.cachedAnchorY = this.getAnchorY();\n    }\n\n    this.tracker.track(event);\n\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n\n    super.onPointerMove(event);\n  }\n\n  protected onPointerUp(event: AdaptedPointerEvent): void {\n    if (!this.rotationGestureDetector) {\n      this.tracker.resetTracker();\n      return;\n    }\n\n    if (this.tracker.getTrackedPointersCount() > 1) {\n      this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n      this.tracker.removeFromTracker(event.pointerId);\n    } else {\n      this.tracker.removeFromTracker(event.pointerId);\n      this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n      if (this.currentState !== State.ACTIVE) {\n        return;\n      }\n    }\n\n    if (event.eventType !== EventTypes.UP) {\n      return;\n    }\n\n    if (this.currentState === State.ACTIVE) {\n      this.end(event);\n    } else {\n      this.fail(event);\n    }\n  }\n\n  protected onPointerCancel(event: AdaptedPointerEvent): void {\n    this.end(event);\n    this.reset();\n  }\n\n  protected tryBegin(event: AdaptedPointerEvent): void {\n    if (this.currentState !== State.UNDETERMINED) {\n      return;\n    }\n\n    this.resetProgress();\n\n    this.begin(event);\n  }\n\n  protected activate(event: AdaptedPointerEvent, _force?: boolean): void {\n    if (this.currentState !== State.ACTIVE) {\n      this.resetProgress();\n    }\n\n    super.activate(event);\n  }\n\n  protected onReset(): void {\n    if (this.currentState === State.ACTIVE) {\n      return;\n    }\n\n    this.rotation = 0;\n    this.velocity = 0;\n  }\n}\n"]}