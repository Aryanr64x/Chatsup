{"version":3,"sources":["GestureHandlerOrchestrator.ts"],"names":["GestureHandlerOrchestrator","constructor","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","i","gestureHandlers","length","isFinished","getState","isAwaiting","splice","hasOtherHandlerToWaitFor","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","event","addAwaitingHandler","makeActive","cleanupAwaitingHandlers","awaitingHandlers","onHandlerStateChange","newState","oldState","State","END","cancel","ACTIVE","isActive","sendEvent","BEGAN","UNDETERMINED","CANCELLED","indexOf","currentState","setShouldResetProgress","activationIndex","shouldHandlerBeCancelledBy","handlersToCancel","push","end","alreadyExists","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","handlerPointers","getTrackedPointersID","otherPointers","PointerTracker","shareCommonPointers","getView","checkOverlap","shouldBeCancelledByOther","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","getEventManager","isPointerInBounds","x","y","otherX","otherY","state","FAILED","getInstance","instance"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { AdaptedPointerEvent } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n      if (!handler) {\n        continue;\n      }\n\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(\n    handler: GestureHandler,\n    event: AdaptedPointerEvent\n  ): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else {\n      this.makeActive(handler, event);\n    }\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    event: AdaptedPointerEvent\n  ): void {\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel(event);\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler, event);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler, event);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(event, newState, oldState);\n      } else if (oldState === State.ACTIVE) {\n        handler.sendEvent(event, newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(event, newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(\n    handler: GestureHandler,\n    event: AdaptedPointerEvent\n  ): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel(event);\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel(event);\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(event, State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(event, State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(event, State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      handler.end(event);\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        handler\n          .getEventManager()\n          .isPointerInBounds({ x: handlerX, y: handlerY }) &&\n        otherHandler\n          .getEventManager()\n          .isPointerInBounds({ x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getEventManager().isPointerInBounds({ x: otherX, y: otherY }) &&\n        otherHandler\n          .getEventManager()\n          .isPointerInBounds({ x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance)\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"]}