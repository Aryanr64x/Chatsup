"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _interfaces = require("../interfaces");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class EventManager {
  constructor(view) {
    _defineProperty(this, "activePointers", []);

    _defineProperty(this, "view", void 0);

    this.view = view;
  }

  setListeners() {
    this.view.addEventListener('pointerdown', event => {
      if (!this.isPointerInBounds({
        x: event.clientX,
        y: event.clientY
      })) {
        return;
      }

      const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.DOWN);
      const target = event.target;
      target.setPointerCapture(adaptedEvent.pointerId);
      this.addActivePointer(adaptedEvent.pointerId);
      this.onPointerDown(adaptedEvent);
    });
    this.view.addEventListener('pointerup', event => {
      const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.UP);
      const target = event.target;
      this.onPointerUp(adaptedEvent);
      target.releasePointerCapture(adaptedEvent.pointerId);
      this.removeActivePointer(adaptedEvent.pointerId);
    });
    this.view.addEventListener('pointermove', event => {
      if (event.pointerType === 'mouse' && event.buttons !== _interfaces.MouseButtons.LEFT) {
        return;
      }

      const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.MOVE);
      const inBounds = this.isPointerInBounds({
        x: adaptedEvent.x,
        y: adaptedEvent.y
      });
      const pointerIndex = this.activePointers.indexOf(adaptedEvent.pointerId);

      if (inBounds) {
        if (pointerIndex < 0) {
          adaptedEvent.eventType = _interfaces.EventTypes.ENTER;
          this.onPointerEnter(adaptedEvent);
          this.addActivePointer(adaptedEvent.pointerId);
        } else {
          this.onPointerMove(adaptedEvent);
        }
      } else {
        if (pointerIndex >= 0) {
          adaptedEvent.eventType = _interfaces.EventTypes.OUT;
          this.onPointerOut(adaptedEvent);
          this.removeActivePointer(adaptedEvent.pointerId);
        } else {
          this.onPointerOutOfBounds(adaptedEvent);
        }
      }
    });
    this.view.addEventListener('pointercancel', event => {
      event.preventDefault();
      const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.CANCEL);
      this.onPointerCancel(adaptedEvent);
    });
  }

  onPointerDown(_event) {}

  onPointerUp(_event) {}

  onPointerMove(_event) {}

  onPointerOut(_event) {}

  onPointerEnter(_event) {}

  onPointerCancel(_event) {}

  onPointerOutOfBounds(_event) {}

  setOnPointerDown(callback) {
    this.onPointerDown = callback;
  }

  setOnPointerUp(callback) {
    this.onPointerUp = callback;
  }

  setOnPointerMove(callback) {
    this.onPointerMove = callback;
  }

  setOnPointerOut(callback) {
    this.onPointerOut = callback;
  }

  setOnPointerEnter(callback) {
    this.onPointerEnter = callback;
  }

  setOnPointerCancel(callback) {
    this.onPointerCancel = callback;
  }

  setOnPointerOutOfBounds(callback) {
    this.onPointerOutOfBounds = callback;
  }

  mapEvent(event, eventType) {
    return {
      x: event.clientX,
      y: event.clientY,
      offsetX: event.offsetX,
      offsetY: event.offsetY,
      pointerId: event.pointerId,
      eventType: eventType,
      pointerType: event.pointerType,
      buttons: event.buttons,
      time: event.timeStamp
    };
  }

  isPointerInBounds({
    x,
    y
  }) {
    if (!this.view) {
      return false;
    }

    const rect = this.view.getBoundingClientRect();
    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
  }

  addActivePointer(pointerId) {
    if (this.activePointers.indexOf(pointerId) >= 0) {
      return;
    }

    this.activePointers.push(pointerId);
  }

  removeActivePointer(pointerId) {
    const index = this.activePointers.indexOf(pointerId);

    if (index < 0) {
      return;
    }

    this.activePointers.splice(index, 1);
  }

}

exports.default = EventManager;
//# sourceMappingURL=EventManager.js.map