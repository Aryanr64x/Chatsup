import { State } from '../../State';
import { Config, AdaptedPointerEvent } from '../interfaces';
import EventManager from '../tools/EventManager';
import InteractionManager from '../tools/InteractionManager';
import PointerTracker from '../tools/PointerTracker';
export default abstract class GestureHandler {
    private lastSentState;
    protected currentState: State;
    protected shouldCancellWhenOutside: boolean;
    protected hasCustomActivationCriteria: boolean;
    protected enabled: boolean;
    private ref;
    private propsRef;
    protected config: Config;
    private handlerTag;
    protected view: HTMLElement | null;
    protected eventManager: EventManager;
    protected tracker: PointerTracker;
    protected interactionManager: InteractionManager;
    protected activationIndex: number;
    protected awaiting: boolean;
    protected active: boolean;
    protected shouldResetProgress: boolean;
    constructor();
    protected init(ref: number, propsRef: React.RefObject<unknown>): void;
    private setView;
    private setEventManager;
    setInteractionManager(manager: InteractionManager): void;
    protected onCancel(): void;
    protected onReset(): void;
    protected resetProgress(): void;
    reset(): void;
    moveToState(newState: State, event: AdaptedPointerEvent): void;
    protected onStateChange(_newState: State, _oldState: State): void;
    begin(event: AdaptedPointerEvent): void;
    fail(event: AdaptedPointerEvent): void;
    cancel(event: AdaptedPointerEvent): void;
    protected activate(event: AdaptedPointerEvent, _force?: boolean): void;
    end(event: AdaptedPointerEvent): void;
    isAwaiting(): boolean;
    setAwaiting(value: boolean): void;
    isActive(): boolean;
    setActive(value: boolean): void;
    getShouldResetProgress(): boolean;
    setShouldResetProgress(value: boolean): void;
    getActivationIndex(): number;
    setActivationIndex(value: number): void;
    shouldWaitForHandlerFailure(handler: GestureHandler): boolean;
    shouldRequireToWaitForFailure(handler: GestureHandler): boolean;
    shouldRecognizeSimultaneously(handler: GestureHandler): boolean;
    shouldBeCancelledByOther(handler: GestureHandler): boolean;
    protected onPointerDown(_event: AdaptedPointerEvent): void;
    protected onPointerAdd(_event: AdaptedPointerEvent): void;
    protected onPointerUp(_event: AdaptedPointerEvent): void;
    protected onPointerRemove(_event: AdaptedPointerEvent): void;
    protected onPointerMove(event: AdaptedPointerEvent): void;
    protected onPointerOut(_event: AdaptedPointerEvent): void;
    protected onPointerEnter(_event: AdaptedPointerEvent): void;
    protected onPointerCancel(_event: AdaptedPointerEvent): void;
    protected onPointerOutOfBounds(event: AdaptedPointerEvent): void;
    private tryToSendMoveEvent;
    sendEvent: (event: AdaptedPointerEvent, newState: State, oldState: State) => void;
    private transformEventData;
    protected transformNativeEvent(_event: AdaptedPointerEvent): {};
    updateGestureConfig({ enabled, ...props }: {
        [x: string]: any;
        enabled?: boolean | undefined;
    }): void;
    protected checkCustomActivationCriteria(criterias: string[]): void;
    private validateHitSlops;
    private checkHitSlop;
    protected resetConfig(): void;
    getTag(): number;
    setTag(tag: number): void;
    protected getConfig(): Config;
    getShouldEnableGestureOnSetup(): boolean;
    getView(): HTMLElement | null;
    getEventManager(): EventManager;
    getTracker(): PointerTracker;
    getTrackedPointersID(): number[];
    getState(): State;
    protected setShouldCancelWhenOutside(flag: boolean): void;
    protected getShouldCancelWhenOutside(): boolean;
}
