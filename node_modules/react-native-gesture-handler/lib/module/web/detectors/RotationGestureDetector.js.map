{"version":3,"sources":["RotationGestureDetector.ts"],"names":["EventTypes","RotationGestureDetector","constructor","callbacks","NaN","onRotationBegin","onRotation","onRotationEnd","updateCurrent","event","tracker","previousTime","currentTime","time","firstPointerID","secondPointerID","keyPointers","firstPointerX","getLastX","firstPointerY","getLastY","secondPointerX","secondPointerY","vectorX","vectorY","anchorX","anchorY","angle","Math","atan2","rotation","Number","isNaN","previousAngle","PI","finish","isInProgress","setKeyPointers","pointerIDs","getData","keys","next","value","onTouchEvent","adaptEvent","eventType","DOWN","ADDITIONAL_POINTER_DOWN","MOVE","ADDITIONAL_POINTER_UP","indexOf","pointerId","UP","getTrackedPointersCount","getTimeDelta","getAnchorX","getAnchorY","getRotation"],"mappings":"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","sourcesContent":["import { AdaptedPointerEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => boolean;\n  onRotationEnd: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => boolean;\n  onRotationEnd: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private rotation = 0;\n\n  private anchorX = 0;\n  private anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(\n    event: AdaptedPointerEvent,\n    tracker: PointerTracker\n  ): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerX: number = tracker.getLastX(firstPointerID);\n    const firstPointerY: number = tracker.getLastY(firstPointerID);\n    const secondPointerX: number = tracker.getLastX(secondPointerID);\n    const secondPointerY: number = tracker.getLastY(secondPointerID);\n\n    const vectorX: number = secondPointerX - firstPointerX;\n    const vectorY: number = secondPointerY - firstPointerY;\n\n    this.anchorX = (firstPointerX + secondPointerX) / 2;\n    this.anchorY = (firstPointerY + secondPointerY) / 2;\n\n    //Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n    this.rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this.rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this.rotation += Math.PI;\n    }\n  }\n\n  private finish(event: AdaptedPointerEvent): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this, event);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.getData().keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(\n    event: AdaptedPointerEvent,\n    tracker: PointerTracker\n  ): boolean {\n    this.adaptEvent(event, tracker);\n\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this, event);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish(event);\n        }\n\n        break;\n\n      case EventTypes.UP:\n        this.finish(event);\n        break;\n    }\n\n    return true;\n  }\n\n  private adaptEvent(\n    event: AdaptedPointerEvent,\n    tracker: PointerTracker\n  ): void {\n    if (\n      tracker.getTrackedPointersCount() &&\n      event.eventType === EventTypes.DOWN\n    ) {\n      event.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n    }\n\n    if (\n      tracker.getTrackedPointersCount() > 1 &&\n      event.eventType === EventTypes.UP\n    ) {\n      event.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n    }\n  }\n\n  public getTimeDelta(): number {\n    return this.currentTime + this.previousTime;\n  }\n\n  public getAnchorX(): number {\n    return this.anchorX;\n  }\n\n  public getAnchorY(): number {\n    return this.anchorY;\n  }\n\n  public getRotation(): number {\n    return this.rotation;\n  }\n}\n"]}