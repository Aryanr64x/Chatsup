function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable @typescript-eslint/no-empty-function */
import { findNodeHandle } from 'react-native';
import { State } from '../../State';
import EventManager from '../tools/EventManager';
import GestureHandlerOrchestrator from '../tools/GestureHandlerOrchestrator';
import PointerTracker from '../tools/PointerTracker';
export default class GestureHandler {
  // Orchestrator properties
  constructor() {
    _defineProperty(this, "lastSentState", null);

    _defineProperty(this, "currentState", State.UNDETERMINED);

    _defineProperty(this, "shouldCancellWhenOutside", false);

    _defineProperty(this, "hasCustomActivationCriteria", void 0);

    _defineProperty(this, "enabled", false);

    _defineProperty(this, "ref", void 0);

    _defineProperty(this, "propsRef", void 0);

    _defineProperty(this, "config", {
      enabled: false
    });

    _defineProperty(this, "handlerTag", void 0);

    _defineProperty(this, "view", null);

    _defineProperty(this, "eventManager", void 0);

    _defineProperty(this, "tracker", new PointerTracker());

    _defineProperty(this, "interactionManager", void 0);

    _defineProperty(this, "activationIndex", 0);

    _defineProperty(this, "awaiting", false);

    _defineProperty(this, "active", false);

    _defineProperty(this, "shouldResetProgress", false);

    _defineProperty(this, "sendEvent", (event, newState, oldState) => {
      const {
        onGestureHandlerEvent,
        onGestureHandlerStateChange
      } = this.propsRef.current;
      const resultEvent = this.transformEventData(event, newState, oldState); // In the new API oldState field has to be undefined, unless we send event state changed
      // Here the order is flipped to avoid workarounds such as making backup of the state and setting it to undefined first, then changing it back
      // Flipping order with setting oldState to undefined solves issue, when events were being sent twice instead of once
      // However, this may cause trouble in the future (but for now we don't know that)

      if (this.lastSentState !== newState) {
        this.lastSentState = newState;
        invokeNullableMethod(onGestureHandlerStateChange, resultEvent);
      }

      if (this.currentState === State.ACTIVE) {
        resultEvent.nativeEvent.oldState = undefined;
        invokeNullableMethod(onGestureHandlerEvent, resultEvent);
      }
    });

    this.hasCustomActivationCriteria = false;
  } //
  // Initializing handler
  //


  init(ref, propsRef) {
    this.propsRef = propsRef;
    this.ref = ref;
    this.currentState = State.UNDETERMINED;
    this.setView(ref);
    this.setEventManager();
  }

  setView(ref) {
    if (!ref) {
      this.view = null;
      return;
    }

    this.view = findNodeHandle(ref);
    this.view.style['touchAction'] = 'none';
    this.view.style['webkitUserSelect'] = 'none';
    this.view.style['userSelect'] = 'none'; //@ts-ignore This one disables default events on Safari

    this.view.style['WebkitTouchCallout'] = 'none';
  }

  setEventManager() {
    if (!this.view) {
      return;
    }

    this.eventManager = new EventManager(this.view);
    this.eventManager.setOnPointerDown(this.onPointerDown.bind(this));
    this.eventManager.setOnPointerUp(this.onPointerUp.bind(this));
    this.eventManager.setOnPointerMove(this.onPointerMove.bind(this));
    this.eventManager.setOnPointerEnter(this.onPointerEnter.bind(this));
    this.eventManager.setOnPointerOut(this.onPointerOut.bind(this));
    this.eventManager.setOnPointerCancel(this.onPointerCancel.bind(this));
    this.eventManager.setOnPointerOutOfBounds(this.onPointerOutOfBounds.bind(this));
    this.eventManager.setListeners();
  }

  setInteractionManager(manager) {
    this.interactionManager = manager;
  } //
  // Resetting handler
  //


  onCancel() {}

  onReset() {}

  resetProgress() {}

  reset() {
    this.tracker.resetTracker();
    this.onReset();
    this.currentState = State.UNDETERMINED;
  } //
  // State logic
  //


  moveToState(newState, event) {
    if (this.currentState === newState) {
      return;
    }

    const oldState = this.currentState;
    this.currentState = newState;
    GestureHandlerOrchestrator.getInstance().onHandlerStateChange(this, newState, oldState, event);
    this.onStateChange(newState, oldState);
  }

  onStateChange(_newState, _oldState) {}

  begin(event) {
    if (!this.checkHitSlop(event)) {
      return;
    }

    if (this.currentState === State.UNDETERMINED) {
      this.moveToState(State.BEGAN, event);
    }
  }

  fail(event) {
    if (this.currentState === State.ACTIVE || this.currentState === State.BEGAN) {
      this.moveToState(State.FAILED, event);
    }

    this.resetProgress();
  }

  cancel(event) {
    if (this.currentState === State.ACTIVE || this.currentState === State.UNDETERMINED || this.currentState === State.BEGAN) {
      this.onCancel();
      this.moveToState(State.CANCELLED, event);
    }
  }

  activate(event, _force = false) {
    if (this.currentState === State.UNDETERMINED || this.currentState === State.BEGAN) {
      this.moveToState(State.ACTIVE, event);
    }
  }

  end(event) {
    if (this.currentState === State.BEGAN || this.currentState === State.ACTIVE) {
      this.moveToState(State.END, event);
    }

    this.resetProgress();
  } //
  // Methods for orchestrator
  //


  isAwaiting() {
    return this.awaiting;
  }

  setAwaiting(value) {
    this.awaiting = value;
  }

  isActive() {
    return this.active;
  }

  setActive(value) {
    this.active = value;
  }

  getShouldResetProgress() {
    return this.shouldResetProgress;
  }

  setShouldResetProgress(value) {
    this.shouldResetProgress = value;
  }

  getActivationIndex() {
    return this.activationIndex;
  }

  setActivationIndex(value) {
    this.activationIndex = value;
  }

  shouldWaitForHandlerFailure(handler) {
    if (handler === this) {
      return false;
    }

    return this.interactionManager.shouldWaitForHandlerFailure(this, handler);
  }

  shouldRequireToWaitForFailure(handler) {
    if (handler === this) {
      return false;
    }

    return this.interactionManager.shouldRequireHandlerToWaitForFailure(this, handler);
  }

  shouldRecognizeSimultaneously(handler) {
    if (handler === this) {
      return true;
    }

    return this.interactionManager.shouldRecognizeSimultaneously(this, handler);
  }

  shouldBeCancelledByOther(handler) {
    if (handler === this) {
      return false;
    }

    return this.interactionManager.shouldHandlerBeCancelledBy(this, handler);
  } //
  // Event actions
  //


  onPointerDown(_event) {
    GestureHandlerOrchestrator.getInstance().recordHandlerIfNotPresent(this);
  } // Adding another pointer to existing ones


  onPointerAdd(_event) {}

  onPointerUp(_event) {} // Removing pointer, when there is more than one pointers


  onPointerRemove(_event) {}

  onPointerMove(event) {
    this.tryToSendMoveEvent(event, false);
  }

  onPointerOut(_event) {}

  onPointerEnter(_event) {}

  onPointerCancel(_event) {}

  onPointerOutOfBounds(event) {
    this.tryToSendMoveEvent(event, true);
  }

  tryToSendMoveEvent(event, out) {
    if (this.currentState === State.ACTIVE && (!out || out && !this.shouldCancellWhenOutside)) {
      this.sendEvent(event, this.currentState, this.currentState);
    }
  } //
  // Events Sending
  //


  transformEventData(event, newState, oldState) {
    var _this$eventManager;

    return {
      nativeEvent: {
        numberOfPointers: this.tracker.getTrackedPointersCount(),
        state: newState,
        pointerInside: (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.isPointerInBounds({
          x: event.x,
          y: event.y
        }),
        ...this.transformNativeEvent(event),
        handlerTag: this.handlerTag,
        target: this.ref,
        oldState: newState !== oldState ? oldState : undefined
      },
      timeStamp: Date.now()
    };
  }

  transformNativeEvent(_event) {
    return {};
  } //
  // Handling config
  //


  updateGestureConfig({
    enabled = true,
    ...props
  }) {
    this.config = {
      enabled,
      ...props
    };
    this.validateHitSlops();
  }

  checkCustomActivationCriteria(criterias) {
    for (const key in this.config) {
      if (criterias.indexOf(key) >= 0) {
        this.hasCustomActivationCriteria = true;
      }
    }
  }

  validateHitSlops() {
    if (!this.config.hitSlop) {
      return;
    }

    if (this.config.hitSlop.left !== undefined && this.config.hitSlop.right !== undefined && this.config.hitSlop.width !== undefined) {
      throw new Error('HitSlop Error: Cannot define left, right and width at the same time');
    }

    if (this.config.hitSlop.width !== undefined && this.config.hitSlop.left === undefined && this.config.hitSlop.right === undefined) {
      throw new Error('HitSlop Error: When width is defined, either left or right has to be defined');
    }

    if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top !== undefined && this.config.hitSlop.bottom !== undefined) {
      throw new Error('HitSlop Error: Cannot define top, bottom and height at the same time');
    }

    if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top === undefined && this.config.hitSlop.bottom === undefined) {
      throw new Error('HitSlop Error: When height is defined, either top or bottom has to be defined');
    }
  }

  checkHitSlop(event) {
    if (!this.config.hitSlop || !this.view) {
      return true;
    }

    const width = this.view.getBoundingClientRect().width;
    const height = this.view.getBoundingClientRect().height;
    let left = 0;
    let top = 0;
    let right = width;
    let bottom = height;

    if (this.config.hitSlop.horizontal !== undefined) {
      left -= this.config.hitSlop.horizontal;
      right += this.config.hitSlop.horizontal;
    }

    if (this.config.hitSlop.vertical !== undefined) {
      top -= this.config.hitSlop.vertical;
      bottom += this.config.hitSlop.vertical;
    }

    if (this.config.hitSlop.left !== undefined) {
      left = -this.config.hitSlop.left;
    }

    if (this.config.hitSlop.right !== undefined) {
      right = width + this.config.hitSlop.right;
    }

    if (this.config.hitSlop.top !== undefined) {
      top = -this.config.hitSlop.top;
    }

    if (this.config.hitSlop.bottom !== undefined) {
      bottom = width + this.config.hitSlop.bottom;
    }

    if (this.config.hitSlop.width !== undefined) {
      if (this.config.hitSlop.left !== undefined) {
        right = left + this.config.hitSlop.width;
      } else if (this.config.hitSlop.right !== undefined) {
        left = right - this.config.hitSlop.width;
      }
    }

    if (this.config.hitSlop.height !== undefined) {
      if (this.config.hitSlop.top !== undefined) {
        bottom = top + this.config.hitSlop.height;
      } else if (this.config.hitSlop.bottom !== undefined) {
        top = bottom - this.config.hitSlop.height;
      }
    }

    if (event.offsetX >= left && event.offsetX <= right && event.offsetY >= top && event.offsetY <= bottom) {
      return true;
    }

    return false;
  }

  resetConfig() {} //
  // Getters and setters
  //


  getTag() {
    return this.handlerTag;
  }

  setTag(tag) {
    this.handlerTag = tag;
  }

  getConfig() {
    return this.config;
  }

  getShouldEnableGestureOnSetup() {
    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');
  }

  getView() {
    return this.view;
  }

  getEventManager() {
    return this.eventManager;
  }

  getTracker() {
    return this.tracker;
  }

  getTrackedPointersID() {
    return this.tracker.getTrackedPointersID();
  }

  getState() {
    return this.currentState;
  }

  setShouldCancelWhenOutside(flag) {
    this.shouldCancellWhenOutside = flag;
  }

  getShouldCancelWhenOutside() {
    return this.shouldCancellWhenOutside;
  }

}

function invokeNullableMethod(method, event) {
  if (!method) {
    return;
  }

  if (typeof method === 'function') {
    method(event);
    return;
  }

  if ('__getHandler' in method && typeof method.__getHandler === 'function') {
    const handler = method.__getHandler();

    invokeNullableMethod(handler, event);
    return;
  }

  if (!('__nodeConfig' in method)) {
    return;
  }

  const {
    argMapping
  } = method.__nodeConfig;

  if (!Array.isArray(argMapping)) {
    return;
  }

  for (const [index, [key, value]] of argMapping.entries()) {
    if (!(key in event.nativeEvent)) {
      continue;
    } // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access


    const nativeValue = event.nativeEvent[key]; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

    if (value !== null && value !== void 0 && value.setValue) {
      //Reanimated API
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
      value.setValue(nativeValue);
    } else {
      //RN Animated API
      method.__nodeConfig.argMapping[index] = [key, nativeValue];
    }
  }

  return;
}
//# sourceMappingURL=GestureHandler.js.map