{"version":3,"sources":["PinchGestureHandler.ts"],"names":["State","DEFAULT_TOUCH_SLOP","EventTypes","GestureHandler","ScaleGestureDetector","PinchGestureHandler","onScaleBegin","detector","startingSpan","getCurrentSpan","onScale","event","prevScaleFactor","scale","getScaleFactor","tracker","getTrackedPointersCount","delta","getTimeDelta","velocity","Math","abs","spanSlop","currentState","BEGAN","activate","onScaleEnd","_detector","_event","scaleDetectorListener","init","ref","propsRef","setShouldCancelWhenOutside","updateGestureConfig","enabled","props","transformNativeEvent","focalX","scaleGestureDetector","getFocusX","focalY","getFocusY","onPointerDown","addToTracker","tryBegin","onTouchEvent","onPointerUp","removeFromTracker","pointerId","ACTIVE","end","eventType","UP","fail","onPointerMove","track","onPointerOutOfBounds","onPointerCancel","reset","UNDETERMINED","resetProgress","begin","force","onReset"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { DEFAULT_TOUCH_SLOP } from '../constants';\nimport { AdaptedPointerEvent, EventTypes } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nimport ScaleGestureDetector, {\n  ScaleGestureListener,\n} from '../detectors/ScaleGestureDetector';\n\nexport default class PinchGestureHandler extends GestureHandler {\n  private scale = 1;\n  private velocity = 0;\n\n  private startingSpan = 0;\n  private spanSlop = 0;\n\n  private scaleDetectorListener: ScaleGestureListener = {\n    onScaleBegin: (detector: ScaleGestureDetector): boolean => {\n      this.startingSpan = detector.getCurrentSpan();\n      return true;\n    },\n    onScale: (\n      detector: ScaleGestureDetector,\n      event: AdaptedPointerEvent\n    ): boolean => {\n      const prevScaleFactor: number = this.scale;\n      this.scale *= detector.getScaleFactor(\n        this.tracker.getTrackedPointersCount()\n      );\n\n      const delta = detector.getTimeDelta();\n      if (delta > 0) {\n        this.velocity = (this.scale - prevScaleFactor) / delta;\n      }\n\n      if (\n        Math.abs(this.startingSpan - detector.getCurrentSpan()) >=\n          this.spanSlop &&\n        this.currentState === State.BEGAN\n      ) {\n        this.activate(event);\n      }\n      return true;\n    },\n    onScaleEnd: (\n      _detector: ScaleGestureDetector,\n      _event: AdaptedPointerEvent\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ): void => {},\n  };\n\n  private scaleGestureDetector: ScaleGestureDetector = new ScaleGestureDetector(\n    this.scaleDetectorListener\n  );\n\n  public init(ref: number, propsRef: React.RefObject<unknown>) {\n    super.init(ref, propsRef);\n\n    this.setShouldCancelWhenOutside(false);\n    this.spanSlop = DEFAULT_TOUCH_SLOP;\n  }\n\n  public updateGestureConfig({ enabled = true, ...props }): void {\n    super.updateGestureConfig({ enabled: enabled, ...props });\n\n    this.enabled = enabled;\n  }\n\n  protected transformNativeEvent(_event: AdaptedPointerEvent) {\n    return {\n      focalX: this.scaleGestureDetector.getFocusX(),\n      focalY: this.scaleGestureDetector.getFocusY(),\n      velocity: this.velocity,\n      scale: this.scale,\n    };\n  }\n\n  protected onPointerDown(event: AdaptedPointerEvent): void {\n    super.onPointerDown(event);\n\n    this.tracker.addToTracker(event);\n\n    if (this.tracker.getTrackedPointersCount() < 2) {\n      return;\n    }\n\n    if (this.tracker.getTrackedPointersCount() > 1) {\n      this.tryBegin(event);\n      this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    }\n  }\n  protected onPointerUp(event: AdaptedPointerEvent): void {\n    if (this.tracker.getTrackedPointersCount() > 1) {\n      this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n      this.tracker.removeFromTracker(event.pointerId);\n    } else {\n      this.tracker.removeFromTracker(event.pointerId);\n      if (this.currentState !== State.ACTIVE) {\n        return;\n      }\n      this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    }\n    if (\n      this.currentState === State.ACTIVE &&\n      this.tracker.getTrackedPointersCount() < 2\n    ) {\n      this.end(event);\n    } else if (\n      event.eventType === EventTypes.UP &&\n      this.currentState !== State.BEGAN\n    ) {\n      this.fail(event);\n    }\n  }\n  protected onPointerMove(event: AdaptedPointerEvent): void {\n    if (this.tracker.getTrackedPointersCount() < 2) {\n      return;\n    }\n    this.tracker.track(event);\n\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerMove(event);\n  }\n  protected onPointerOutOfBounds(_event: AdaptedPointerEvent): void {\n    //\n  }\n\n  protected onPointerCancel(_event: AdaptedPointerEvent): void {\n    this.reset();\n  }\n\n  private tryBegin(event: AdaptedPointerEvent): void {\n    if (this.currentState !== State.UNDETERMINED) {\n      return;\n    }\n\n    this.resetProgress();\n\n    this.begin(event);\n  }\n\n  protected activate(event: AdaptedPointerEvent, force?: boolean): void {\n    if (this.currentState !== State.ACTIVE) {\n      this.resetProgress();\n    }\n\n    super.activate(event, force);\n  }\n\n  protected onReset(): void {\n    this.resetProgress();\n  }\n\n  protected resetProgress(): void {\n    if (this.currentState === State.ACTIVE) {\n      return;\n    }\n\n    this.velocity = 0;\n    this.scale = 1;\n  }\n}\n"]}